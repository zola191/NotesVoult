## IEnumerable
- **Описание** :  
    Интерфейс `IEnumerable` содержит метод `GetEnumerator`, который возвращает объект-перечислитель. Объект-перечислитель реализует интерфейс `IEnumerator`.
    
- **Состав IEnumerator** :
    
    - `object Current`:  
        Свойство `Current` возвращает значение текущего элемента коллекции. Его можно только получить – задать или изменить не выйдет (**get-only** ).
    - `bool MoveNext()`:  
        Метод `MoveNext` пытается переместить указатель на следующий элемент коллекции. Возвращает `true`, если это получилось, или `false`, если нет.
    - `void Reset()`:  
        Метод `Reset` сбрасывает указатель на изначальное место.
- **Ожидания от перечислителя** :  
    Перечислитель должен:
    
    - Идти по массиву.
    - При каждой попытке перейти на следующую позицию уведомлять, получилось ли это.
    - Если переход успешен – возвращать элемент массива по текущему индексу.
    
    Для этого необходимо:
    
    - Передавать массив заранее.
    - Ввести поле для хранения текущей позиции (индекса). По умолчанию: `-1` (перед первым элементом).
- **Пример использования** :  
    Работа с файлом через `IEnumerable`. Без `IEnumerable` пришлось бы загружать весь файл в память. С `IEnumerable` происходит построчное выполнение через `foreach`.

---

## IQueryable

- **Описание** :  
    Унифицированный интерфейс, чаще всего используемый для работы с базами данных. Наследуется от `IEnumerable`.
    
- **Особенности IQueryable** :
    
    - **IQueryProvider** :  
        Поставщик запросов, который знает, как построить SQL-запрос (реализует `EntityQueryProvider`).
    - **Expression** :  
        Дерево выражений, которое позволяет выполнять запросы (не обязательно SQL).
- **Пример метода Where** :
    
    - Для `IEnumerable`:
```csharp
	
	this IEnumerable<TSource> source, Func<TSource, bool>
```
    - Для `IQueryable`:
        
```csharp
	this IQueryable<TSource> source, Expression<Func<TSource, bool>>
```

- **Дерево выражений** :  
    Это не исполняемый код, а структура данных, которая описывает логику выражения. Она может быть преобразована в другой формат, например, в SQL.
    
- **Различия в выполнении запросов** :
    
    - `IEnumerable`:  
        Выполнение на стороне клиента. Забирает все данные из БД и обрабатывает их в памяти клиента.
    - `IQueryable`:  
        Выполнение на стороне сервера. Забирает точечные данные из БД, что позволяет более эффективно обрабатывать большие или сложные наборы данных.


## Когда что использовать?


### ✔️ Используйте IEnumerable когда:

1. Работаете с коллекциями в памяти
2. Нужны все методы LINQ (некоторые доступны только для IEnumerable, пример .ElementAt(), .ToDictionary(), .Zip(), .Aggregate() )
3. Данные уже загружены или их мало
    

### ✔️ Используйте IQueryable когда:

1. Работаете с базой данных (Entity Framework)
2. Нужно комбинировать условия динамически
3. Хотите минимизировать передачу данных
4. Работаете с большими объемами данных



✅ **Оба интерфейса поддерживают отложенное выполнение**, но работают принципиально по-разному:

|                                | `IEnumerable`                         | `IQueryable`                                |
| ------------------------------ | ------------------------------------- | ------------------------------------------- |
| **Тип отложенного выполнения** | Ленивая оценка (lazy evaluation)      | Построение выражения (expression trees)     |
| **Когда выполняется**          | При итерации (foreach, ToList и т.д.) | При переводе выражения в запрос (SQL и др.) |
| **Где выполняется**            | В памяти (клиентская сторона)         | На сервере (БД, удалённый источник)         |

```csharp
var query = users.Where(u => u.Age > 18); // 1. Создаётся цепочка итераторов
                                          // (данные НЕ загружаются)

foreach (var user in query)               // 2. Выполнение происходит здесь:
{                                        // - Фильтрация в памяти
    Console.WriteLine(user.Name);         // - Построчное чтение
}
```

```csharp
var query = db.Users                     // 1. Строится дерево выражений
               .Where(u => u.Age > 18);  // (запрос НЕ отправляется в БД)

var results = query.ToList();            // 2. Выполнение происходит здесь:
                                         // - Генерация SQL
                                         // - Отправка запроса
                                         // - Получение результатов
```

### Оптимизация запросов

```csharp
// IEnumerable - ВСЕ операции выполняются в памяти после загрузки ВСЕХ данных
var result = users
    .Where(u => u.Age > 18)    // 1. Загружаются ВСЕ пользователи из БД
                               // 2. Фильтрация (Age > 18) происходит в памяти
    .OrderBy(u => u.Name)      // 3. Сортировка по имени в памяти
    .Take(10);                 // 4. Берется 10 первых из уже отфильтрованных

// IQueryable - операции преобразуются в SQL и выполняются на сервере
var result = db.Users          // Начинаем с IQueryable (не загружая данные)
    .Where(u => u.Age > 18)    // Преобразуется в WHERE Age > 18 в SQL
    .OrderBy(u => u.Name)      // Преобразуется в ORDER BY Name в SQL
    .Take(10);                 // Преобразуется в TOP 10 / LIMIT 10 в SQL
// На сервер уходит ОПТИМИЗИРОВАННЫЙ запрос
SELECT TOP 10 * FROM Users 
WHERE Age > 18 
ORDER BY Name
```

1. Почему `IQueryable` наследуется от `IEnumerable`?
    Позволяет использовать IQueryable везде, где ожидается IEnumerable
2. Что произойдет, если смешать `IEnumerable` и `IQueryable` без `AsEnumerable()`?
    - Часть запроса выполнится на сервере, а часть - в памяти
**Пример опасного кода:**
```csharp
var results = db.Users
           .Where(u => u.Age > 18) // IQueryable (SQL)
           .Where(u => ComplexCheck(u)) // IEnumerable (в памяти!)
           .ToList();
```
➡️ **Последствия:**
	1. Сначала выполнится `SELECT * FROM Users WHERE Age > 18` (загрузка ВСЕХ подходящих записей)
	2. Затем фильтрация `ComplexCheck()` в памяти приложения
✅ **Решение:**
```csharp
var results = db.Users
           .Where(u => u.Age > 18)
           .AsEnumerable() // Явное переключение
           .Where(u => ComplexCheck(u))
           .ToList();
```

3. Как избежать N+1 проблемы в Entity Framework?
	1. **Eager Loading** (явная загрузка):
```csharp
var users = db.Users
             .Include(u => u.Posts) // JOIN в одном запросе
             .ToList();
```
	2. **Projection** (выборка только нужных данных):
```csharp
var userDtos = db.Users
                .Select(u => new UserDto {
                    Name = u.Name,
                    PostCount = u.Posts.Count // Считается в SQL
                })
                .ToList();
```
	3. **Explicit Loading** (для сложных сценариев):
```csharp
var user = db.Users.First();
db.Entry(user)
  .Collection(u => u.Posts)
  .Query()
  .Where(p => p.IsPublic)
  .Load(); // Загружает по условию
```
4. В чем преимущество ленивого выполнения?
Данные загружаются только при необходимости