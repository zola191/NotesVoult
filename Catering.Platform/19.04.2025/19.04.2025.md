

# Обработка исключений в ASP.NET Core

## Классификация исключений

### Контролируемые (ожидаемые)
1. **Ошибки валидации** (ValidationException)
2. **Бизнес-ошибки** (например, InsufficientFundsException)
3. **Ошибки доступа** (UnauthorizedAccessException)
4. **Ошибки "Не найдено"** (EntityNotFoundException)
5. **Конфликты данных** (OptimisticConcurrencyException)

### Неконтролируемые (критические)
1. **Системные ошибки**:
   - OutOfMemoryException
   - StackOverflowException
   - AccessViolationException
2. **Инфраструктурные сбои**:
   - DatabaseConnectionException
   - ExternalServiceUnavailableException
3. **Runtime-краши**:
   - TypeInitializationException
   - JITCompilerException

> **Важно**: Неконтролируемые ошибки часто требуют перезапуска сервиса.

## Механизмы обработки в ASP.NET Core

### 1. Встроенные механизмы
```csharp
// Разные обработчики для разных окружений
if (env.IsDevelopment())
{
    app.UseDeveloperExceptionPage(); // Детальный stack trace
}
else
{
    app.UseExceptionHandler("/Error"); // User-friendly страница
}
```

### 2. Кастомный Middleware (рекомендуется для Web API)

```csharp

public class ErrorHandlingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ErrorHandlingMiddleware> _logger;

    public ErrorHandlingMiddleware(RequestDelegate next, ILogger<ErrorHandlingMiddleware> logger)
    {
        _next = next; // ссылка на след. делегат
        _logger = logger; // логирование никогда не бывает лишним, но не стоит логировать чувствительные данные (узнать у тех. лида по проекту, что можно логировать, а что нет?)
    }

    public async Task Invoke(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unhandled exception");
            context.Response.StatusCode = 500;
            context.Response.ContentType = "application/json";
            await context.Response.WriteAsync(JsonSerializer.Serialize(new
            {
                error = "Произошла внутренняя ошибка сервера"
            }));
        // В production не раскрываем ex.Message!
        }
    }
}
```

способ регистрации самописного middleware

```csharp
app.UseMiddleware<ErrorHandlingMiddleware>();
```

### 3. Exception Filters (точечная обработка)
например обработка только одной ошибки только в одном контроллере которого нигде нет больше
```csharp
public class GlobalExceptionFilter : IExceptionFilter
{
    private readonly ILogger<GlobalExceptionFilter> _logger;

    public GlobalExceptionFilter(ILogger<GlobalExceptionFilter> logger)
    {
        _logger = logger;
    }

    public void OnException(ExceptionContext context)
    {
        _logger.LogError(context.Exception, "Exception caught in filter");

        context.Result = new ObjectResult(new { error = "Что-то пошло не так" })
        {
            StatusCode = 500
        };
    }
}
```

способ регистрации самописного Filter

```csharp
services.AddControllers(options =>
{
    options.Filters.Add<GlobalExceptionFilter>();
});
```

## Best Practices

### 1. Problem Details (RFC 7807)

**Расширенная версия**:
```csharp
var problem = new ProblemDetails
{
    Status = 500,
    Title = "Ошибка сервера",
    Detail = ex.Message,
    Instance = context.Request.Path
};

context.Response.StatusCode = 500;
context.Response.ContentType = "application/problem+json";

var json = JsonSerializer.Serialize(problem);
await context.Response.WriteAsync(json);

// можно расширять ProblemDetails за счет наследования

public class CustomProblemDetails : ProblemDetails
{
    public string TraceId { get; set; }
    public Dictionary<string, object> Metadata { get; set; }
}

public class ExtendedProblemDetails : ProblemDetails
{
    public string ErrorCode { get; set; }
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;
}
```

после внесения корректировок в Middleware

```csharp
public class ErrorHandlingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ErrorHandlingMiddleware> _logger;

    public ErrorHandlingMiddleware(RequestDelegate next, ILogger<ErrorHandlingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task Invoke(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unhandled exception");
			var problem = new ProblemDetails
			{
			    Status = 500,
			    Title = "Ошибка сервера",
			    Detail = ex.Message,
			    Instance = context.Request.Path
			};
			
			context.Response.StatusCode = 500;
			context.Response.ContentType = "application/problem+json";
			
			var json = JsonSerializer.Serialize(problem);
			await context.Response.WriteAsync(json);
		}
	}
}
```

### 2. Обработка Validation Errors

```csharp
services.PostConfigure<ApiBehaviorOptions>(options =>
{
    options.InvalidModelStateResponseFactory = ctx => 
    {
        var problem = new ValidationProblemDetails(ctx.ModelState)
        {
            Type = "https://tools.ietf.org/html/rfc7231#section-6.5.1",
            Title = "One or more validation errors occurred"
        };
        return new BadRequestObjectResult(problem);
    };
});
```

### 3. Логирование

**Правила**:

- Всегда включать TraceId
    
- Не логировать PII-данные (пароли, токены)
    
- Использовать структурированное логгирование:

```csharp
_logger.LogError(
    "Ошибка при обработке запроса {RequestId}. Параметры: {Params}",
    traceId, 
    new { context.Request.Path, Query = context.Request.QueryString });
```

## Важные уточнения

1. **Middleware vs Filters**:
    
    - Middleware - для глобальных ошибок
        
    - Filters - для специфичных сценариев (например, валидация в контроллере)
        
2. **Безопасность**:
    
    - В production никогда не возвращайте stack trace
        
    - Используйте разные уровни детализации для разных окружений
        
3. **Производительность**:
    
    - Exception handling дорогой - для бизнес-ошибок лучше использовать Result-паттерн
        
    - Не используйте исключения для flow control


### **Подходы к валидации данных в ASP.NET Core**

---

## **1. DataAnnotations (Встроенная валидация)**

**Когда использовать**:

- Простые проверки (обязательные поля, длина строки, регулярные выражения).
    
- Быстрое прототипирование.
    

**Пример**:


```csharp
[ApiController] // Включает автоматическую валидацию
public class UserController : ControllerBase
{
    public class CreateUserRequest
    {
        [Required(ErrorMessage = "Имя обязательно")]
        [StringLength(50, MinimumLength = 2, ErrorMessage = "Длина имени от 2 до 50 символов")]
        public string Name { get; set; }

        [EmailAddress(ErrorMessage = "Некорректный email")]
        public string Email { get; set; }
    }

    [HttpPost("create")]
    public IActionResult Create([FromBody] CreateUserRequest request)
    {
        return Ok("OK");
    }
}
```

**Что возвращает при ошибке**:

```json
{
  "type": "https://tools.ietf.org/html/rfc7231#section-6.5.1",
  "title": "Validation Error",
  "status": 400,
  "errors": {
    "Name": ["Имя обязательно"],
    "Email": ["Некорректный email"]
  }
}
```

**Плюсы**:

- Встроено в ASP.NET Core.
    
- Минимальный boilerplate-код (без кучи лишних строк кода)
    

**Минусы**:

- Сложно расширять (например, проверка уникальности email в БД).
    
- Нет поддержки сложных условий (например, "если поле A равно X, то поле B обязательно").
    

---

## **2. FluentValidation (Кастомная валидация)**

**Когда использовать**:

- Сложные бизнес-правила.
    
- Переиспользуемые валидаторы.
    
- Валидация, требующая запросов к БД.
    

**Пример**:


```csharp

public class CreateUserRequestValidator : AbstractValidator<CreateUserRequest>
{
    public CreateUserRequestValidator(IUserRepository userRepo)
    {
        RuleFor(x => x.Name)
            .NotEmpty().WithMessage("Имя обязательно")
            .Length(2, 50).WithMessage("Длина имени от 2 до 50 символов");

        RuleFor(x => x.Email)
            .EmailAddress().WithMessage("Некорректный email")
            .MustAsync(async (email, _) => !await userRepo.ExistsAsync(email))
            .WithMessage("Email уже занят");
    }
}
```
**Регистрация**:


```csharp
services.AddScoped<IValidator<CreateUserRequest>, CreateUserRequestValidator>();
services.AddFluentValidationAutoValidation(); // Интеграция с ASP.NET Core
```
**Плюсы**:

- Гибкость (можно инжектить сервисы).
    
- Читаемый DSL-синтаксис.
    
- Поддержка асинхронных проверок.
    

**Минусы**:

- Требует подключения отдельной библиотеки (`FluentValidation`).
    

---

## **3. Аудит изменений (Audit Logging)**

**Зачем**:

- Отслеживание, кто и когда изменил данные.
    
- Восстановление предыдущих состояний.
    

### **Способы реализации**:

#### **1. Переопределение `SaveChanges` в EF Core**


```csharp
public override async Task<int> SaveChangesAsync(CancellationToken ct = default)
{
    var auditEntries = new List<AuditEntry>();

    foreach (var entry in ChangeTracker.Entries<IAuditable>())
    {
        if (entry.State == EntityState.Modified || entry.State == EntityState.Added)
        {
            auditEntries.Add(new AuditEntry
            {
                EntityId = entry.Entity.Id,
                OldValues = entry.State == EntityState.Modified 
                    ? JsonSerializer.Serialize(entry.OriginalValues.ToObject()) 
                    : null,
                NewValues = JsonSerializer.Serialize(entry.CurrentValues.ToObject()),
                ChangedBy = _currentUserService.GetUserId(),
                ChangedAt = DateTime.UtcNow
            });
        }
    }

    await _auditLogRepository.AddRangeAsync(auditEntries);
    return await base.SaveChangesAsync(ct);
}
```


Поле `RecordVersion` в сущности `Dish` реализует **оптимистичную блокировку** (optimistic concurrency control) и **трекинг изменений** без сложного аудит-логирования. Это лёгкий способ отслеживать, "кто и когда менял данные".

По истории значений можно понять, **сколько раз** меняли запись (но не что именно меняли!).

`RecordVersion` — это **минимум для отслеживания изменений**

```csharp
public class Dish : Entity
{
    public string Name { get; set; } = null!;
    public string Description { get; set; } = null!;
    public decimal Price { get; set; }
    public Guid CategoryId { get; set; }
    public Category Category { get; set; } = null!;
    public string? ImageUrl { get; set; } = string.Empty;
    public bool IsAvailable { get; set; }
    public IngredientList Ingredients { get; set; }
    public AllergenList Allergens { get; set; }
    public string PortionSize { get; set; }
	//для аудита
    public int RecordVersion { get;set; }
}
```


#### **2. Триггеры в БД (для high-load систем)**


```sql

CREATE TRIGGER trg_Dish_Audit
ON Dishes
AFTER INSERT, UPDATE, DELETE
AS
BEGIN
    INSERT INTO DishAuditLog (DishId, OldData, NewData, ChangedBy, ChangedAt)
    SELECT 
        ISNULL(i.Id, d.Id),
        (SELECT * FROM DELETED FOR JSON AUTO),
        (SELECT * FROM INSERTED FOR JSON AUTO),
        SYSTEM_USER,
        GETUTCDATE()
    FROM INSERTED i
    FULL JOIN DELETED d ON i.Id = d.Id;
END
```

**Плюсы триггеров**:

- Не влияет на производительность приложения.
    
- Работает даже при прямых SQL-запросах.
    

**Минусы**:

- Сложнее отлаживать.
    
- Привязка к конкретной СУБД.
    

---

## **Best Practices**

1. **Для валидации**:
    
    - `DataAnnotations` — для простых сценариев.
        
    - `FluentValidation` — для сложной логики.
        
2. **Для аудита**:
    
    - `SaveChanges` + `BackgroundService` — если нужно логировать в фоне.
        
    - Триггеры — если критична производительность.
        
3. **Возврат ошибок**:
    
    - Всегда используйте `ProblemDetails` для API.
        
    - В production скрывайте детали ошибок (`ex.Message` → "Произошла ошибка").
        
4. **Логирование**:
    
    - Структурированные логи (Serilog + Seq/Grafana).
        
    - Обязательно включать `TraceId` для отслеживания цепочек.
        

```csharp

// Пример логирования
_logger.LogError(
    "Ошибка при создании пользователя. RequestId: {TraceId}, Data: {@Request}",
    HttpContext.TraceIdentifier,
    request
);
```
**Итог**:

- Валидация должна быть явной и тестируемой.
    
- Аудит — обязателен для критичных данных.
    
- Ошибки — безопасны для пользователя и информативны для разработчика.


#задача поиграться с Program Details в отдельном проекте 
Program Details можно 
nuget: Microsoft.AspNetCore.Mvc.Core
Microsoft.AspNetCore.Mvc.Abstractions.dll

```csharp
[ApiController]
[Route("api/[controller]")]
public class TestController : ControllerBase
{
    [HttpGet("crash")]
    public IActionResult Crash()
    {
        throw new Exception("Что-то пошло не так"); //возвращает Program Details с 500 ошибкой
    }
}
```

Exception Filter vs Middleware
отлавливать только в контроллере Exception Filter
отлавливать все ошибки везде Middleware
управление pipeline Middleware
вернуть ошибку в виде IActionResult Exception Filter пример 302 код с редиректом на страницу ошибки (Razor Aplication)

#читать
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-9.0

#задача консольное приложение которое дергает API проекта
CancelationSource таймер на 300 мсек после которого идет обрыв соединения
т.е. моделирование CancelationToken внутри консольного приложения

многошаговые операции обрабатываются внутри API
но CancelationSource создается за пределами API в консольном приложении

План на новое занятие для ознакомления
Авторизация
Аутентификация

**Кэширование**
**Unit тесты** XUnit NSubstitute Moq

репозитории нет смысла тестировать
достаточно тестировать контроллеры, сервисы, валидаторы, handler CQRS
60% покрытие кода тестами необходимо и достаточно
тестировать при пограничных значениях
ветвление необходимо тоже тестировать
### основные правила тестирования
1. 1 тест 1 сценарий 
2. в самом тесте не должно быть сложной имплементации, может быть дублирования кода, чем проще тест чем лучше, рефлексию не использовать при тестировании или нужно четко понимать зачем это делается

#### Литература для изучения тестирования
- ART OF UNIT TESTING книга для unit тестирования для начала
- Хориков про тестирования для enterprice с принципами DDD для более продвинутого пользователя
- Паттерн XUnit


#задача для TenantViewModel и Создать сущность `Tenant` с полями сделать отдельный PR

остальную часть тикета сделать в другмо PR
