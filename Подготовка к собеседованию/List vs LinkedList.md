# Массив
## Определение
Массив — это структура данных, представляющая собой:
- Набор **однотипных** элементов
- Элементы располагаются в памяти **последовательно** друг за другом
- Объединены общим именем
- Размер массива **фиксирован** после создания

## Характеристики
- **Элемент массива**: отдельная переменная в составе массива (можно изменять)
- **Индекс элемента**: порядковый номер элемента (начинается с 0)
- **Размерность**: количество элементов в массиве (Length)
- **Фиксированный размер**: нельзя изменить после создания
- 
Адрес_элемента = Адрес_начала_массива + (Индекс × Размер_элемента)

# Список
## Определение  
`List<T>` — это универсальная коллекция в C#, которая:
- Динамически расширяется (аналог `ArrayList`, но типобезопасный)
- Реализует интерфейсы `IList<T>`, `IEnumerable<T>`, `ICollection<T>`
- Поддерживает индексацию, добавление, удаление и поиск элементов

## Внутренняя реализация (как работает под капотом)
- **В основе лежит обычный массив (T[])**, который при необходимости пересоздаётся
- При создании без указания capacity по умолчанию используется пустой массив
- При добавлении элементов:
  - Если места в массиве достаточно, элемент добавляется в конец
  - Если массив заполнен, создаётся новый массив в 2 раза большего размера (это важно для амортизированной сложности O(1) на добавление)
  - Все элементы копируются в новый массив
- При удалении элементов массив не уменьшается автоматически, но можно вызвать `TrimExcess()`

## Основные операции  
### Инициализация  
```csharp
List<int> numbers = new List<int>();  // Внутренний массив = empty
List<string> names = new List<string>(10);  // Внутренний массив размером 10
```

1. Почему при увеличении (Capacity) массив увеличивается именно в 2 раза?
    - _Ответ:_ Это компромисс между количеством реаллокаций и использованием памяти. Увеличение в 2 раза даёт амортизированную сложность O(1) для операции Add.
2. Как можно избежать многократных реаллокаций при добавлении большого количества элементов?
    - _Ответ:_ Указать предполагаемый размер через конструктор `new List<T>(capacity)`
3. В чём разница между Count и Capacity?
    - _Ответ:_ Count - количество фактически хранимых элементов, Capacity - размер внутреннего массива
4. Что происходит с внутренним массивом при вызове Clear()?
    - _Ответ:_ Массив остаётся прежнего размера, но все элементы удаляются (Count = 0)
5. Чем `List<T>` отличается от массива (`T[]`)?
    - _Ответ:_ Массив имеет фиксированный размер, `List<T>` динамически расширяется.
6. Когда лучше использовать `List<T>`, а когда `LinkedList<T>`?
    - _Ответ:_ `List` для частого доступа по индексу, `LinkedList` для частых вставок/удалений в середине.
7. Как уменьшить количество реаллокаций при добавлении элементов?
    - _Ответ:_ Задать начальную `Capacity`.

