## Что такое многопоточность
**Многопоточность** — это возможность выполнения нескольких потоков (threads) внутри одного процесса, позволяющая параллельно обрабатывать задачи и эффективно использовать ресурсы процессора.

**Процесс** — это экземпляр выполняемой программы/приложения (word excel), который изолирован от других процессов (чтобы не мог навредить другому процессу)  и имеет собственные ресурсы: память, потоки и т. д.

**Поток** — это наименьшая единица выполнения внутри процесса (единица которой процессор выделяет свое время в котором происходят какие либо действия), которая может выполняться параллельно с другими потоками. Потоки разделяют ресурсы своего родительского процесса (память, файлы), но имеют собственный стек вызовов.

### **Процесс vs Поток (Thread)**

| Характеристика   | Процесс                           | Поток (Thread)                      |
| ---------------- | --------------------------------- | ----------------------------------- |
| **Изоляция**     | Полная (своя память)              | Разделяет память процесса           |
| **Создание**     | Тяжелее (нужна отдельная среда)   | Легче (использует ресурсы процесса) |
| **Переключение** | Медленнее (из-за смены контекста) | Быстрее                             |
| **Надёжность**   | Безопаснее (падение не влияет)    | Ошибка может убить весь процесс     |

в чем разница между асинхронным программированием и многопоточным?
Всегда ли асинхронность выполняется в нескольких потоках? ответ нет см как выполнен eventloop в javascript (однопоточный язык программирования)
как создать поток ? new Thread это класс который связан с потоками операционной системы, через данный класс можно выставить приоритет т.е. если нам нужен поток с нестандартным приоритетом, то используем Thread 
потоки бывают двух видов активные и фоновые
приложение перестает работать когда нет ни одного активного потока
у потока есть свой приоритет от 0 до 31 который складывается из двух значений приоритета процесса и потока
минусы использования Thread
создавать поток дорогостоящая операция
операция не очень длительная, например операция длится 3 милисекунды и создавать поток избыточно т.к. мы можем создавать поток дольше чем сама операция
## Thread Pool
зачем нам создавать поток если можно создать целую пачку потоков за раз и использовать их когда они нужны это и есть пул потоков
когда создается приложение в вашем процессе будет пул потоков которым распоряжается CLR 
Работали ли вы с многопоточностью? ответ нет неприемлем т.к. не работать с многопоточностью сейчас нельзя пример async await подразумеваем работу с многопоточностью т.к. вызов выполнялся на пуле потоков 
Пул потоков закрывает все задачи или можно использовать Thread?
когда требуется создать поток явно
- когда требуется поток с нестандартным приоритетом (тут нужен пример) сборщик мусора работает в отдельном высокоприоритетным потоке 
- когда нужно создать активный поток (нужно определение активного и пассивного потока)
- когда операция будет выполняться долго (можно ли BackgroundService отнести к этому? )

## ValueTask
это не действие это обещание что задача будет выполнена
нужны в одном случае когда не факт что метод будет выполняться асинхронном (нужен пример)
напоминание Task это ссылочный тип 

## async await
```csharp
async Task Get()
{
	Console.WriteLine("");
	await repo.Get();
}
Main()
{
	await Get();
}
```

state машина количество состояний равно количеству await (это верно?)
почему нельзя указывать void вместо Task?
1. не сможем указать await
2. ошибки (что именно тут?)

## Race Condition (гонка данных)
аномалия в многопоточном программировании результат случаен и зависит от того как начнут работать потоки (добавить пример про инкремент и декремент)

для исключения данных случаев нужны примитивы синхронизации

1. lock
2. monitor
3. mutex
4. semaphore
5. semaphoreSlim
6. interlocked
7. volatile

чтобы избежать ситуации которая описана выше можно решить задачу через lock
lock{
	await Get().ConfigureAwait(false)??
	это может собраться но работать будет некорректно
}
но так делать нельзя если хотите поработать с асинхронными операциями используй semaphoreslim

volatile если переменная помеченная таким словом, то CLR с ним по другому себя ведет поток читает всегда актуальные значения
(volatile не является примитивом синхронизации но идет рука об руку с блоком вопросов по примитивам синхронизации)

interlocked 
для чего может пригодиться?
если хотим сделать инкремент, то первое что нужно сделать это прочитать значение потом добавить значение вот interlocked позволяет это выполнить в рамках атомарной операции
что такое атомарная операция?? выполняется полностью или не выполняется вовсе
примитивы синхронизации нужны для того чтобы обезопасить наши данные при работе в несколько потоков

TaskWhenAll (IEnumerable<Task>)

если несколько задач выполняется параллельно, то можно дождаться TaskWhenAll
тут нужен пример
в чем отличие WhenAll от WaitAll?
что если у нас много задач и нужно дождаться первую? 
await task.whenany(массив тасок)

ConcurrentCollection
зачем нужно
расписать для заметки

Однопоточность - система в одном потоке работает со всеми задачами, выполняя их поочерёдно.
Асинхронность - Основана на идее выполнения задач, не блокируя вызывающий их поток во время длительных операций, которые могут выполняться в других процессах, например, обращение к БД или сетевые запросы. Асинхронность позволяет потоку, начавшему выполнение задачи, приостановить выполнение сохранив текущее состояние, не дожидаясь окончания ее выполнения, и взять в работу другую задачу. 
Таким образом, если задача не требует процессорного времени, а задействует сеть, БД, диск, то стоит использовать асинхронный подход
Многопоточность Concurrency -  это подход к выполнению нескольких задач в разных потоках, при котором задачи могут запускаться, исполняться и завершаться в пересекающиеся промежутки времени, но это не означает их одновременное выполнение как в параллелизме. Многопоточность подразумевает использование нескольких потоков внутри одного процесса Потоки в одном процессе разделяют общую память благодаря чему между ними можно обмениваться данными, но необходимо тщательно настраивать синхронизацию данных.
Управлением временем выполнения потока в ядре занимается планировщик задач системы, который выделяет на каждый поток некоторый случайный квант времени. По истечении выделенного потоку кванта, текущее состояние потока сохраняется в TLS (Thread Local Storage), и текущий поток временно замораживается, в работу на ядро проца отправляется следующий поток. Когда очередь приходит обратно к замороженному потоку, он возобновляет свою работу, восстанавливая свои данные из TLS. После полного завершения работы потока, он высвобождается из управления планировщиком.
Параллельность Parallelism - одновременное выполнение нескольких задач в нескольких потоках, которые одновременно выполняются на разных ядрах процессора
Почему не стоит делать возвращаемое значение void у асинхронных методов
Методы, которые возвращают Task или Task<TResult>, позволяют отслеживать завершение асинхронных операций, обрабатывать исключения и отмену. Когда асинхронный метод возвращает void, из вызывающего кода не получится отследить завершение метода и обработать возможные исключения из-за потери контекст стека вызовов. 
То есть при возникновении исключения в данном асинхронном методе стек вызовов не будет раскручен в вызывающий код и необработанное исключение улетит в среду приложения, а стек вызовов для данного исключения даже не пропишется в логах.
как под капотом выглядит асинхронная задача ?
async/await являются синтаксическим сахаром. Когда компилятор обрабатывает метод, помеченный async, он преобразует его в структуру, которая реализует конечный автомат (state machine), управляющий переходами между различными состояниями асинхронного метода 
есть 4 состояния начальное, приостановлено, возобновлено, завершено, дополнительные состояния ошибка и отменено
Когда метод стартует, MoveNext() начинает выполнение первой части кода, до первого await т.е. код до первого await выполняется синхронно 
Проверяется завершена ли задача через GetAwaiter который возвращает объект Awaite ? как правило она не завершена 
AwaitUnsafeOnCompleted метод запоминает/регистрирует что нам делать когда задача завершится 
return отпускает наш поток в пул потоков
Как OC оповещает CLR о выполнении задачи? Когда операция завершена, ОС отправляет сигнал в CLR через механизм завершающего порта (Completion Ports), указывая на завершение конкретной задачи.
Получив уведомление о завершении, CLR вызывает нужный обратный вызов или возобновляет выполнение метода, который был приостановлен с помощью await. Это происходит автоматически через вызов метода MoveNext() в состоянии асинхронного метода
Result: Блокирует выполнение текущего потока, ожидая завершения задачи. Это синхронное ожидание, и оно не позволяет продолжить выполнение программы, пока не будет получен результат.
Примитивы синхронизации
lock
lock разворачивается в try finally 
bool trigger = false; // Указатель активности блокировки
        try
        {
            Monitor.Enter(magicBall, ref trigger); // Блокируем для других потоков
            x = 1;
            for (int i = 1; i < 11; i++)
            {
                Console.WriteLine($"{Thread.CurrentThread.Name}: {x}");
                ++x;
                Thread.Sleep(100);
            }
        }
        finally
        {
            if (trigger)
            {
                Monitor.Exit(magicBall); // Освобождаем блокировку
            }
        }
В качестве объекта-заглушки может быть что угодно, лишь бы это был экземпляр ссылочного типа данных. (статический)
Статический объект обеспечивает синхронизацию доступа для всех экземпляров класса, а не только для одного экземпляра
При использовании статического объекта все потоки будут блокироваться на одном и том же объекте
lock работает только в рамках одного процесса (процесс - это экземпляр программы, которая выполняется на компьютере)
lock typeof(object)
приводит к синхронизации на единственном экземпляре объекта типа System.Type для всех классов object
в lock нельзя использовать await когда придет ответ для выполнения, то новый поток не сможет зайти в в блок с lock т.к. блок заблокирован
Mutex 
mutex работает в рамках разных процессов на уровне OC т.е. mutex решает проблему межпроцессорного взаимодействия, например на одном компьютере и запущены два одинаковых приложения.
using (var mutex = new Mutex(false, "MyMutexName")
важно задать имя при создании mutex
Semaphore
тоже самое что mutex, но у semaphore может быть много потоков, т.е. могут зайти несколько потоков в критическую секцию
semaphoe(1) т.е. с одним потоком = mutex(Name1)
SemaphoreSlim это облегченная версия, оптимизированная для работы в пределах одного процесса и не обращается к OC
утрировано это lock, но с несколькими потоками, но тут уже можно использовать await.
RedLock 
это алгоритм распределенной блокировки, разработанный для систем, использующих Redis как распределённое хранилище
Deadlock - мертвая блокировка и взаимная блокировка

GetAwaiter() через возвращаемый объект awaiter отслеживает завершение асинхронной операции и управляет продолжением выполнения программы после завершения задачи.
public async Task ExampleAsync()
{
    Task task = SomeAsyncMethod();
    await task; // Здесь вызывается task.GetAwaiter().GetResult();
}
Возвращаемый объект: Метод GetAwaiter возвращает объект, который имеет методы IsCompleted, GetResult() и, возможно, OnCompleted(Action continuation). Эти методы позволяют управлять асинхронным выполнением.


