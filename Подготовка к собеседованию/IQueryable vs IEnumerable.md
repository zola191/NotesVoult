# IEnumerable

IEnumerable - В данном интерфейсе содержится метод GetEnumerator, который возвращает объект-перечислитель. Объект-перечислитель реализует интерфейс IEnumerator
IEnumerator содержит в себе:
object Current. Свойство Current возвращает значение текущего элемента коллекции. Что интересно, его можно только получить – задать или изменить не выйдет, то есть он -- getonly.
bool MoveNext(). Метод MoveNext пытается переместить указатель на следующий элемент коллекции, и возвращает true, если это получилось, или же false, если нет.
void Reset(). Метод Reset сбрасывает указатель на изначальное место.
Что мы ждем от нашего перечислителя: он должен идти по массиву, и при каждой попытке перейти на следующую позицию – уведомлять нас, получилось ли это. Если получилось – возвращать элемент, находящийся в массиве по данному индексу. Значит нам придется передавать ему наш массив заранее, а также ввести свое поле, содержащее позицию (индекс) в этом массиве, на которой мы остановились (по умолчанию -1, перед первым элементом)
IEnumerable на примере работы с файлом, если бы не было IEnumerable, то нам бы пришлось загружать весь файл в память и обрабатывать с IEnumerable происходит построчное выполнение через foreach
IQuerable - это унифицированный интерфейс чаще всего используемый для баз данных, наследуется от IEnumerable, но кроме этого у IQuerable есть
IQueryProvider (поставщик запросов реализует EntityQueryProvider и который знает как построить SQL запрос) 
Expression - это дерево выражений которое позволяет выполнять SQL(необязательно SQL) запрос 
Для примера рассмотрим метод Where для IEnumerable и IQuerable
в IEnumerable будет передавать this IEnumerable<TSource> source Func<Tsource, bool>, то в IQuerable this IQuerable<TSource> source  Expression<Func<Tsource, bool>>
Дерево выражений: Это не исполняемый код, а структура данных, которая описывает логику выражения. Она может быть преобразована в другой формат, например, в SQL.
запросы, использующие IEnumerable выполнение на стороне клиента, т.е. IEnumerable выполняет запрос в памяти клиента, IQueryable выполняет запрос на сервере, что позволяет более эффективно обрабатывать данные, особенно с большими или сложными наборами данных.
IEnumerable забирает все данные из БД
IQueryable забирает точечные данные из БД


## Когда что использовать?


### ✔️ Используйте IEnumerable когда:

1. Работаете с коллекциями в памяти
2. Нужны все методы LINQ (некоторые доступны только для IEnumerable, пример .ElementAt(), .ToDictionary(), .Zip(), .Aggregate() )
3. Данные уже загружены или их мало
    

### ✔️ Используйте IQueryable когда:

1. Работаете с базой данных (Entity Framework)
2. Нужно комбинировать условия динамически
3. Хотите минимизировать передачу данных
4. Работаете с большими объемами данных



✅ **Оба интерфейса поддерживают отложенное выполнение**, но работают принципиально по-разному:

|                                | `IEnumerable`                         | `IQueryable`                                |
| ------------------------------ | ------------------------------------- | ------------------------------------------- |
| **Тип отложенного выполнения** | Ленивая оценка (lazy evaluation)      | Построение выражения (expression trees)     |
| **Когда выполняется**          | При итерации (foreach, ToList и т.д.) | При переводе выражения в запрос (SQL и др.) |
| **Где выполняется**            | В памяти (клиентская сторона)         | На сервере (БД, удалённый источник)         |

```csharp
var query = users.Where(u => u.Age > 18); // 1. Создаётся цепочка итераторов
                                          // (данные НЕ загружаются)

foreach (var user in query)               // 2. Выполнение происходит здесь:
{                                        // - Фильтрация в памяти
    Console.WriteLine(user.Name);         // - Построчное чтение
}
```

```csharp
var query = db.Users                     // 1. Строится дерево выражений
               .Where(u => u.Age > 18);  // (запрос НЕ отправляется в БД)

var results = query.ToList();            // 2. Выполнение происходит здесь:
                                         // - Генерация SQL
                                         // - Отправка запроса
                                         // - Получение результатов
```

### Оптимизация запросов

```csharp
// IEnumerable - ВСЕ операции выполняются в памяти после загрузки ВСЕХ данных
var result = users
    .Where(u => u.Age > 18)    // 1. Загружаются ВСЕ пользователи из БД
                               // 2. Фильтрация (Age > 18) происходит в памяти
    .OrderBy(u => u.Name)      // 3. Сортировка по имени в памяти
    .Take(10);                 // 4. Берется 10 первых из уже отфильтрованных

// IQueryable - операции преобразуются в SQL и выполняются на сервере
var result = db.Users          // Начинаем с IQueryable (не загружая данные)
    .Where(u => u.Age > 18)    // Преобразуется в WHERE Age > 18 в SQL
    .OrderBy(u => u.Name)      // Преобразуется в ORDER BY Name в SQL
    .Take(10);                 // Преобразуется в TOP 10 / LIMIT 10 в SQL
// На сервер уходит ОПТИМИЗИРОВАННЫЙ запрос
SELECT TOP 10 * FROM Users 
WHERE Age > 18 
ORDER BY Name
```