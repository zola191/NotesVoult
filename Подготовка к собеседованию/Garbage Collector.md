#CSharpInterviewFlashcards

## 1. Что такое Garbage Collector
?
# Garbage Collector в C#

## Основные понятия
- **GC** — автоматический менеджер памяти в .NET, освобождающий объекты, которые больше не используются.
- **Поколения (Generations)**:
  - **Gen 0**: Короткоживущие объекты (сборка происходит чаще).
  - **Gen 1**: Буфер между Gen 0 и Gen 2.
  - **Gen 2**: Долгоживущие объекты (например, статические поля).
  - **LOH (Large Object Heap)**: Объекты > 85 КБ (собираются только при полной сборке).

## Как работает GC?
1. **Пометка (Marking)**: GC обходит граф объектов, помечая используемые.
2. **Очистка (Sweeping)**: Удаляет непомеченные объекты.
3. **Компактификация (Compacting)**: Уменьшает фрагментацию (кроме LOH).

## Типы сборок
- **Неполная (Ephemeral)**: Только Gen 0 и Gen 1.
- **Полная (Full)**: Все поколения + LOH.
- **Фоновая (Background)**: Параллельная сборка (Gen 0 и Gen 1 не блокируют поток).
- **Блокирующая (Blocking)**: Приостанавливает все потоки.

## Настройки GC
```csharp
// Включение фоновой сборки (по умолчанию для .NET Core+)
GC.TryStartNoGCRegion(100_000); // Временное отключение GC

// Принудительная сборка (не рекомендуется в продакшене)
GC.Collect(2, GCCollectionMode.Forced, blocking: true);
```
## Ключевые термины

- **Корни (Roots)**: Статические поля, локальные переменные, регистры.
    Это объекты, которые GC считает "живыми" (не подлежащими удалению). Они служат точками входа для анализа графа объектов.
```csharp
	static List<string> _cache = new List<string>(); // Корень

	void Method() 
{
    var temp = new object(); // Корень, пока метод выполняется
}

```

1. **Регистры процессора**
	- Временные ссылки в стеке вызовов (например, параметры методов).

- **Финализация**: Вызов `Finalize` перед удалением (может замедлить GC).
    
- **IDisposable**: Паттерн для ручного освобождения ресурсов (например, файловые потоки).


## **Чем отличаются поколения в GC?**

Поколения оптимизируют работу GC, уменьшая частоту полных сборок.

| Поколение | Описание                    | Частота сборки                        | Примеры                      |
| --------- | --------------------------- | ------------------------------------- | ---------------------------- |
| **Gen 0** | Новые объекты               | Часто (~каждый 1-2 МБ)                | Локальные переменные         |
| **Gen 1** | "Буфер" между Gen 0 и Gen 2 | Реже (~после нескольких сборок Gen 0) | Объекты, пережившие 1 сборку |
| **Gen 2** | Долгоживущие объекты        | Редко (при нехватке памяти)           | Статические поля, кэши       |
| **LOH**   | Объекты > 85 КБ             | Только при Full GC                    | Большие массивы, XML-данные  |

**Ключевое правило:**  
Чем выше поколение, тем дороже его сборка. Gen 0 — быстрый, Gen 2 и LOH — могут вызывать задержки.

## **Что такое LOH и какие проблемы с ним связаны?**

**LOH (Large Object Heap)** — куча для больших объектов (> 85 КБ).

**Особенности:**

- Не компактифицируется (возникает фрагментация).
    
- Собирается только при **Full GC** (Gen 2 + LOH).
    
- Частые аллокации в LOH могут привести к `OutOfMemoryException`.

---

- **GC** — автоматический менеджер памяти в .NET, освобождающий объекты, которые больше не используются.

### Как можно вызвать **Garbage Collector**
1. GC.Collect - ручной вызов (не рекомендуется)
2. Автоматический режим когда превышены пороговые значения в поколениях

В .NET **управляемая куча (managed heap)** делится на **3 поколения** для оптимизации работы сборщика мусора (Garbage Collector). Это позволяет GC быстрее освобождать память, минимизируя задержки.

- **Поколения (Generations)**:
  - **Gen 0**: Короткоживущие объекты (сборка происходит чаще).
  - **Gen 1**: Буфер между Gen 0 и Gen 2.
  - **Gen 2**: Долгоживущие объекты (например, статические поля).
  - **Large Object Heap (LOH)**
	- Объекты > **85 КБ** попадают в **специальную кучу** (не в Gen 0!). 
    - Управляется отдельно, но считается частью **Gen 2**.
    - Собираются только при полной сборке

## **Автоматические триггеры GC**

### **(1) Нехватка памяти в поколении (Gen 0, Gen 1, Gen 2)**

- **Gen 0** (молодые объекты):  
    → Срабатывает **чаще всего** (примерно каждые несколько МБ аллокаций).  
    → Быстро очищает кратковременные объекты (например, временные переменные в методах).
    
- **Gen 1** (промежуточные объекты):  
    → Запускается, **если после сборки Gen 0 памяти всё ещё не хватает**.  
    → Объекты, пережившие сборку Gen 0, попадают сюда.
    
- **Gen 2** (долгоживущие объекты) и **LOH** (Large Object Heap):  
    → Срабатывает **редко**, только при серьезной нехватке памяти.  
    → Например, если Gen 0 + Gen 1 не смогли освободить достаточно памяти.

### **(2) Выделение больших объектов (> 85 КБ)**

- Большие объекты попадают в **Large Object Heap (LOH)**, который считается частью Gen 2.
- Если LOH заполняется, может запуститься **полная сборка (Gen 2)**.

### **(3) Системные события**

- **Нехватка памяти в системе** (Windows отправляет уведомление .NET).
- **Завершение работы домена приложения** (AppDomain).
- **Ручной вызов `GC.Collect()`** (не рекомендуется без причины).

Чаще всего неиспользуемые являются объекты которые созданы недавно 
Если объект пережил первую сборку мусора, то вполне вероятно он и дальше нужен
Сборка мусора всегда начинается с первого поколения, если памяти достаточно, то другие поколения не будут затронуты 

во время работы Gc приостанавливается работа всех потоков

куча делится на
SOH - small object heap
LOH - large object heap

## Как работает GC?
1. **Пометка (Marking)**: GC обходит граф объектов, помечая используемые.\
изначально считается, что все объекты недостижимыми

Какие объекты являются недостижимыми?
Объекты на которых больше нет рутов
рутом являются
- Локальные переменные метода ссылочного типа в методе который сейчас выполняется
- Ссылки на объекты с финализатором
- Статические поля

2. **Очистка (Sweeping)**: Удаляет непомеченные объекты.
3. **Сжатие ()**: Уменьшает фрагментацию в SOH (кроме LOH).

почему нет дефрагментации в LOH
