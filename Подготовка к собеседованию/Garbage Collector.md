#CSharpInterviewFlashcards

## 1. Что такое Garbage Collector
?
# Garbage Collector в C#

## Основные понятия
- **GC** — автоматический менеджер памяти в .NET, освобождающий объекты, которые больше не используются.
- **Поколения (Generations)**:
  - **Gen 0**: Короткоживущие объекты (сборка происходит чаще).
  - **Gen 1**: Буфер между Gen 0 и Gen 2.
  - **Gen 2**: Долгоживущие объекты (например, статические поля).
  - **LOH (Large Object Heap)**: Объекты > 85 КБ (собираются только при полной сборке).

## Как работает GC?
1. **Пометка (Marking)**: GC обходит граф объектов, помечая используемые.
2. **Очистка (Sweeping)**: Удаляет непомеченные объекты.
3. **Компактификация (Compacting)**: Уменьшает фрагментацию (кроме LOH).

## Типы сборок
- **Неполная (Ephemeral)**: Только Gen 0 и Gen 1.
- **Полная (Full)**: Все поколения + LOH.
- **Фоновая (Background)**: Параллельная сборка (Gen 0 и Gen 1 не блокируют поток).
- **Блокирующая (Blocking)**: Приостанавливает все потоки.

## Настройки GC
```csharp
// Включение фоновой сборки (по умолчанию для .NET Core+)
GC.TryStartNoGCRegion(100_000); // Временное отключение GC

// Принудительная сборка (не рекомендуется в продакшене)
GC.Collect(2, GCCollectionMode.Forced, blocking: true);
```
## Ключевые термины

- **Корни (Roots)**: Статические поля, локальные переменные, регистры.
    Это объекты, которые GC считает "живыми" (не подлежащими удалению). Они служат точками входа для анализа графа объектов.
```csharp
	static List<string> _cache = new List<string>(); // Корень

	void Method() 
{
    var temp = new object(); // Корень, пока метод выполняется
}

```

1. **Регистры процессора**
	- Временные ссылки в стеке вызовов (например, параметры методов).

- **Финализация**: Вызов `Finalize` перед удалением (может замедлить GC).
    
- **IDisposable**: Паттерн для ручного освобождения ресурсов (например, файловые потоки).


## **Чем отличаются поколения в GC?**

Поколения оптимизируют работу GC, уменьшая частоту полных сборок.

| Поколение | Описание                    | Частота сборки                        | Примеры                      |
| --------- | --------------------------- | ------------------------------------- | ---------------------------- |
| **Gen 0** | Новые объекты               | Часто (~каждый 1-2 МБ)                | Локальные переменные         |
| **Gen 1** | "Буфер" между Gen 0 и Gen 2 | Реже (~после нескольких сборок Gen 0) | Объекты, пережившие 1 сборку |
| **Gen 2** | Долгоживущие объекты        | Редко (при нехватке памяти)           | Статические поля, кэши       |
| **LOH**   | Объекты > 85 КБ             | Только при Full GC                    | Большие массивы, XML-данные  |

**Ключевое правило:**  
Чем выше поколение, тем дороже его сборка. Gen 0 — быстрый, Gen 2 и LOH — могут вызывать задержки.

## **Что такое LOH и какие проблемы с ним связаны?**

**LOH (Large Object Heap)** — куча для больших объектов (> 85 КБ).

**Особенности:**

- Не компактифицируется (возникает фрагментация).
    
- Собирается только при **Full GC** (Gen 2 + LOH).
    
- Частые аллокации в LOH могут привести к `OutOfMemoryException`.

---

- **GC** — автоматический менеджер памяти в .NET, освобождающий объекты, которые больше не используются.

### Как можно вызвать **Garbage Collector**
1. GC.Collect - ручной вызов (не рекомендуется)
2. Автоматический режим когда превышены пороговые значения в поколениях

В .NET **управляемая куча (managed heap)** делится на **3 поколения** для оптимизации работы сборщика мусора (Garbage Collector). Это позволяет GC быстрее освобождать память, минимизируя задержки.

- **Поколения (Generations)**:
  - **Gen 0**: Короткоживущие объекты (сборка происходит чаще).
  - **Gen 1**: Буфер между Gen 0 и Gen 2.
  - **Gen 2**: Долгоживущие объекты (например, статические поля).
  - **Large Object Heap (LOH)**
	- Объекты > **85 КБ** попадают в **специальную кучу** (не в Gen 0! и не в Gen 2). 
    - Управляется отдельно, но считается частью **Gen 2**.
    - Собираются только при полной сборке

## **Автоматические триггеры GC**

### **(1) Нехватка памяти в поколении (Gen 0, Gen 1, Gen 2)**

- **Gen 0** (молодые объекты):  
    → Срабатывает **чаще всего** (примерно каждые несколько МБ аллокаций).  
    → Быстро очищает кратковременные объекты (например, временные переменные в методах).
    
- **Gen 1** (промежуточные объекты):  
    → Запускается, **если после сборки Gen 0 памяти всё ещё не хватает**.  
    → Объекты, пережившие сборку Gen 0, попадают сюда.
    
- **Gen 2** (долгоживущие объекты) и **LOH** (Large Object Heap):  
    → Срабатывает **редко**, только при серьезной нехватке памяти.  
    → Например, если Gen 0 + Gen 1 не смогли освободить достаточно памяти.

### **(2) Выделение больших объектов (> 85 КБ)**

- Большие объекты попадают в **Large Object Heap (LOH)**, который считается частью Gen 2.
- Если LOH заполняется, может запуститься **полная сборка (Gen 2)**.

### **(3) Системные события**

- **Нехватка памяти в системе** (Windows отправляет уведомление .NET).
- **Завершение работы домена приложения** (AppDomain).
- **Ручной вызов `GC.Collect()`** (не рекомендуется без причины).

Чаще всего неиспользуемые являются объекты которые созданы недавно 
Если объект пережил первую сборку мусора, то вполне вероятно он и дальше нужен
Сборка мусора всегда начинается с первого поколения, если памяти достаточно, то другие поколения не будут затронуты 

во время работы Gc приостанавливается работа всех потоков

куча делится на
SOH - Small Object Heap мене 85 кбайт, делится на поколения Gen 0, 1, 2
LOH - Large Object Heap более 85 кбайт, не является частью Gen
POH - Pinned Object Heap начиная .Net 5 (куча закрепленных объектов, объекты с фиксированным адресом памяти) введено для оптимизации
FOH - Fixed Object Heap начиная .Net 8 (объекты которые живут на протяжении всей жизни приложения и не из POH) введено для оптимизации

## Как работает GC?
1. **Пометка (Marking)**: GC обходит граф объектов, помечая используемые.\
изначально считается, что все объекты недостижимыми

Какие объекты являются недостижимыми?
Объекты на которых больше нет рутов
рутом являются
- Локальные переменные метода ссылочного типа в методе который сейчас выполняется
- Ссылки на объекты с финализатором
- Статические поля

2. **Очистка (Sweeping)**: Удаляет непомеченные объекты.
3. **Сжатие ()**: Уменьшает фрагментацию в SOH (кроме LOH).

почему нет дефрагментации в LOH
потому что _дорого_ переставлять такие объекты

## GC mode

 ### Client Mode
 
- **Описание** :  
	Режим оптимизирован для клиентских приложений, работающих на одном процессоре или с ограниченными ресурсами.
	
	- Использует один поток для сборки мусора.
	- Минимизирует задержки (latency), что важно для интерактивных приложений.
	
- **Характеристики** :
	
	- Быстрее запускается и использует меньше памяти.
	- Подходит для приложений с небольшой нагрузкой.
	
- **Примеры использования** :
	
	- WPF (Windows Presentation Foundation).
	- WinForms (Windows Forms).
	- Десктопные приложения.

 ### Server Mode
 
- **Описание** :  
	Режим оптимизирован для серверных приложений, работающих на многоядерных процессорах.
	
	- Использует несколько потоков сборки мусора (по одному на каждый процессор).
	- Максимизирует пропускную способность (throughput) за счет более эффективного управления памятью.
	
- **Характеристики** :
	
	- Требует больше памяти, но обеспечивает более высокую производительность.
	- Лучше подходит для многопоточных приложений с высокой нагрузкой.
	
- **Примеры использования** :
	
	- ASP.NET и ASP.NET Core (веб-приложения).
	- Серверные приложения, такие как микросервисы или фоновые задачи.

## Что такое финализатор ?

```csharp
class Person
{
	~ Person(){} // деструктор
}
```
- Финализатор в C# — это специальный метод, который вызывается сборщиком мусора (Garbage Collector, GC) перед тем, как объект будет окончательно удален из памяти. Объекты с финализатором помещаются в Finalizer Queue при создании. Когда такие объекты становятся недостижимыми, GC перемещает их из Finalizer Queue в Freachable Queue (очередь финализации). Затем финализаторы этих объектов вызываются Finalizer Thread перед их окончательным удалением. Объект с финализатором всегда переживает первую сборку мусора
- Он используется для освобождения **неуправляемых ресурсов** (unmanaged resources), таких как файловые дескрипторы, сокеты, базы данных, указатели на неуправляемую память и т.д.

Неуправляемые ресурсы — это ресурсы, которые не контролируются средой CLR (Common Language Runtime). Примеры:

- Файловые потоки (`FileStream`).
- Сетевые подключения.
- Базы данных.

- Хотя финализатор может использоваться для освобождения неуправляемых ресурсов, это **не рекомендуемый подход** .
- Вместо финализатора лучше использовать интерфейс `IDisposable` и шаблон **Dispose Pattern** . Это позволяет разработчику явно освободить ресурсы, когда они больше не нужны, без ожидания вызова финализатора