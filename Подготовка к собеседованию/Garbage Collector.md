#CSharpInterviewFlashcards

- **GC** — автоматический менеджер памяти в .NET, освобождающий объекты, которые больше не используются.

### Как можно вызвать **Garbage Collector**
1. GC.Collect - ручной вызов (не рекомендуется)
2. Автоматический режим когда превышены пороговые значения в поколениях

В .NET **управляемая куча (managed heap)** делится на **3 поколения** для оптимизации работы сборщика мусора (Garbage Collector). Это позволяет GC быстрее освобождать память, минимизируя задержки.

- **Поколения (Generations)**:
  - **Gen 0**: Короткоживущие объекты (сборка происходит чаще).
  - **Gen 1**: Буфер между Gen 0 и Gen 2.
  - **Gen 2**: Долгоживущие объекты (например, статические поля).
  - **Large Object Heap (LOH)**
	- Объекты > **85 КБ** попадают в **специальную кучу** (не в Gen 0! и не в Gen 2). 
    - Управляется отдельно, но считается частью **Gen 2**.
    - Собираются только при полной сборке

## **Автоматические триггеры GC**

### **(1) Нехватка памяти в поколении (Gen 0, Gen 1, Gen 2)**

- **Gen 0** (молодые объекты):  
    → Срабатывает **чаще всего** (примерно каждые несколько МБ аллокаций).  
    → Быстро очищает кратковременные объекты (например, временные переменные в методах).
    
- **Gen 1** (промежуточные объекты):  
    → Запускается, **если после сборки Gen 0 памяти всё ещё не хватает**.  
    → Объекты, пережившие сборку Gen 0, попадают сюда.
    
- **Gen 2** (долгоживущие объекты) и **LOH** (Large Object Heap):  
    → Срабатывает **редко**, только при серьезной нехватке памяти.  
    → Например, если Gen 0 + Gen 1 не смогли освободить достаточно памяти.

### **(2) Выделение больших объектов (> 85 КБ)**

- Большие объекты попадают в **Large Object Heap (LOH)**, который считается частью Gen 2.
- Если LOH заполняется, может запуститься **полная сборка (Gen 2)**.

### **(3) Системные события**

- **Нехватка памяти в системе** (Windows отправляет уведомление .NET).
- **Завершение работы домена приложения** (AppDomain).
- **Ручной вызов `GC.Collect()`** (не рекомендуется без причины).

Чаще всего неиспользуемые являются объекты которые созданы недавно 
Если объект пережил первую сборку мусора, то вполне вероятно он и дальше нужен
Сборка мусора всегда начинается с первого поколения, если памяти достаточно, то другие поколения не будут затронуты 

во время работы Gc приостанавливается работа всех потоков

куча делится на
SOH - Small Object Heap мене 85 кбайт, делится на поколения Gen 0, 1, 2
LOH - Large Object Heap более 85 кбайт, не является частью Gen
**Особенности:**
- Не компактифицируется (возникает фрагментация).
- Собирается только при **Full GC** (Gen 2 + LOH).
- Частые аллокации в LOH могут привести к `OutOfMemoryException`.
POH - Pinned Object Heap начиная .Net 5 (куча закрепленных объектов, объекты с фиксированным адресом памяти) введено для оптимизации
FOH - Fixed Object Heap начиная .Net 8 (объекты которые живут на протяжении всей жизни приложения и не из POH) введено для оптимизации

## Как работает GC?
1. **Пометка (Marking)**: GC обходит граф объектов, помечая используемые.\
изначально считается, что все объекты недостижимыми

Какие объекты являются недостижимыми?
Объекты на которых больше нет рутов
рутом являются
- Локальные переменные метода ссылочного типа в методе который сейчас выполняется
- Ссылки на объекты с финализатором
- Статические поля

2. **Очистка (Sweeping)**: Удаляет непомеченные объекты.
3. **Сжатие ()**: Уменьшает фрагментацию в SOH (кроме LOH).

**Ключевое правило:**  
Чем выше поколение, тем дороже его сборка. Gen 0 — быстрый, Gen 2 и LOH — могут вызывать задержки.

почему нет дефрагментации в LOH
потому что _дорого_ переставлять такие объекты

## GC mode

 ### **Client Mode**
 
- **Описание** :  
	Режим оптимизирован для клиентских приложений, работающих на одном процессоре или с ограниченными ресурсами.
	
	- Использует один поток для сборки мусора.
	- Минимизирует задержки (latency), что важно для интерактивных приложений.
	
- **Характеристики** :
	
	- Быстрее запускается и использует меньше памяти.
	- Подходит для приложений с небольшой нагрузкой.
	
- **Примеры использования** :
	
	- WPF (Windows Presentation Foundation).
	- WinForms (Windows Forms).
	- Десктопные приложения.

 ### **Server Mode**
 
- **Описание** :  
	Режим оптимизирован для серверных приложений, работающих на многоядерных процессорах.
	
	- Использует несколько потоков сборки мусора (по одному на каждый процессор).
	- Максимизирует пропускную способность (throughput) за счет более эффективного управления памятью.
	
- **Характеристики** :
	
	- Требует больше памяти, но обеспечивает более высокую производительность.
	- Лучше подходит для многопоточных приложений с высокой нагрузкой.
	
- **Примеры использования** :
	
	- ASP.NET и ASP.NET Core (веб-приложения).
	- Серверные приложения, такие как микросервисы или фоновые задачи.

## Что такое финализатор ?

```csharp
class Person
{
	~ Person(){} // деструктор
}
```
- Финализатор в C# — это специальный метод, который вызывается сборщиком мусора (Garbage Collector, GC) перед тем, как объект будет окончательно удален из памяти. Объекты с финализатором помещаются в Finalizer Queue при создании. Когда такие объекты становятся недостижимыми, GC перемещает их из Finalizer Queue в Freachable Queue (очередь финализации). Затем финализаторы этих объектов вызываются Finalizer Thread перед их окончательным удалением. Объект с финализатором всегда переживает первую сборку мусора
- Он используется для освобождения **неуправляемых ресурсов** (unmanaged resources), таких как файловые дескрипторы, сокеты, базы данных, указатели на неуправляемую память и т.д.

Неуправляемые ресурсы — это ресурсы, которые не контролируются средой CLR (Common Language Runtime). Примеры:

- Файловые потоки (`FileStream`).
- Сетевые подключения.
- Базы данных.

- Хотя финализатор может использоваться для освобождения неуправляемых ресурсов, это **не рекомендуемый подход** .
- Вместо финализатора лучше использовать интерфейс `IDisposable` и шаблон **Dispose Pattern** . Это позволяет разработчику явно освободить ресурсы, когда они больше не нужны, без ожидания вызова финализатора

## Что такое IDisposable ?
**`IDisposable`** — это интерфейс в .NET, предназначенный для явного управления освобождением неуправляемых ресурсов (например, файловых дескрипторов, сетевых подключений, баз данных и т.д.). Он позволяет разработчику контролировать момент высвобождения ресурсов.

### Основные характеристики:

1. **Явное управление ресурсами** :
    
    - В отличие от финализатора, который вызывается сборщиком мусора (GC) в неопределённый момент, `IDisposable` позволяет освободить ресурсы сразу, когда они больше не нужны.
    - Это особенно важно для ресурсов, которые могут быть ограничены или критичны по времени (например, файлы, сокеты).
2. **Метод `Dispose`** :
    
    - Интерфейс `IDisposable` содержит единственный метод:
        
```csharp
void Dispose();
```
        
    - Разработчик реализует этот метод для освобождения неуправляемых ресурсов.
3. **Использование с `using`** :
    
    - Для удобства работы с объектами, реализующими `IDisposable`, используется конструкция `using`:
        
```csharp
	using (var resource = new SomeResource())
	
	{
	
	// Использование ресурса
	
	} // Ресурс автоматически освобождается здесь
	
```

Компилятор преобразует этот код в следующий эквивалент:
```csharp
{
    var resource = new SomeResource();
    try
    {
        // Использование ресурса
    }
    finally
    {
        if (resource != null)
        {
            ((IDisposable)resource).Dispose();
        }
    }
}
```

    - После выхода из блока `using` вызывается метод `Dispose`.
4. **Комбинирование с финализатором** :
    
    - Если класс работает с неуправляемыми ресурсами, он может реализовать как `IDisposable`, так и финализатор. Это обеспечивает гарантированное освобождение ресурсов:
        - `Dispose` вызывается разработчиком для немедленного освобождения.
        - Финализатор служит "страховкой" на случай, если разработчик забудет вызвать `Dispose`.

```csharp
public class ResourceHolder : IDisposable
{
    private bool _disposed = false;
    private IntPtr _unmanagedResource; // Неуправляемый ресурс

    public ResourceHolder()
    {
        _unmanagedResource = AllocateUnmanagedResource();
    }

    ~ResourceHolder()
    {
        Dispose(false); // Вызываем Dispose(false) из финализатора
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this); // Отключаем финализатор
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!_disposed)
        {
            if (disposing)
            {
                // Освобождаем управляемые ресурсы (если есть)
            }

            // Освобождаем неуправляемые ресурсы
            FreeUnmanagedResource(_unmanagedResource);

            _disposed = true;
        }
    }

    private IntPtr AllocateUnmanagedResource()
    {
        // Логика выделения неуправляемого ресурса
        return IntPtr.Zero;
    }

    private void FreeUnmanagedResource(IntPtr resource)
    {
        // Логика освобождения неуправляемого ресурса
    }
}
```