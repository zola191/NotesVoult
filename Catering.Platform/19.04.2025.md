# Мультитенантные архитектуры баз данных

**Тенант** — это **изолированный "клиент"** в системе, который:

- Имеет **свои данные** (пользователей, настройки, контент)
    
- Работает **независимо** от других тенантов
    
- Использует **общее приложение**, но видит только **свою часть**

## 1. Shared Database + Shared Schema (Единая схема)
**Когда использовать**:  
- Стартапы/прототипы с небольшим количеством tenant'ов (<10)
- Когда tenant'ы доверяют друг другу (одна компания/подразделения)

**Плюсы**:
- Нет оверхеда на управление схемами
- Простая миграция из single-tenant приложения
- Все данные в одном месте (удобно для аналитики)

**Минусы**:
- Риск "шумного соседа" (noisy neighbor)
- Сложная изоляция данных (риск утечки между tenant'ами)
- Линейный рост нагрузки (10 tenant'ов = 10x нагрузка)

## 2. Shared Database + Separated Schema
**Реальные кейсы**:
- ERP-системы (например, Oracle E-Business Suite)
- Когда нужна изоляция, но hardware ограничен

**Плюсы**:
- Сильная изоляция на уровне схем
- Общие миграции для всех tenant'ов

**Минусы**:
- Ограничения СУБД на кол-во схем (например, PostgreSQL ~10k схем)
- Сложности с резервным копированием отдельных tenant'ов

## 3. Database per Tenant
**Паттерны подключения**:
1. Динамический ConnectionString (лучше через фабрику подключений)
2. Использование Connection Pool per Tenant

**Плюсы**:
- Полная изоляция (можно даже разные версии БД)
- Гибкое масштабирование (разные SLA для разных tenant'ов)

**Минусы**:
- Сложность кросс-tenant отчетности
- Оверхед на управление миграциями

---

## Практические рекомендации
1. **Где делать mapping**:
   - В CQRS: в handlers (но можно вынести в отдельный слой DTO Assembler)
   - В сервисах: через специализированные Mapper классы

2. **Шардинг vs Мультитенантность**:
   - Шардинг = распределение данных _одного_ tenant'а
   - Мультитенантность = изоляция _разных_ tenant'ов

3. **Горизонтальное масштабирование**:
   - Для Shared DB: только через репликацию read-only
   - Для DB-per-Tenant: можно распределять tenant'ов по серверам

# Обработка исключений в ASP.NET Core

## Классификация исключений

### Контролируемые (ожидаемые)
1. **Ошибки валидации** (ValidationException)
2. **Бизнес-ошибки** (например, InsufficientFundsException)
3. **Ошибки доступа** (UnauthorizedAccessException)
4. **Ошибки "Не найдено"** (EntityNotFoundException)
5. **Конфликты данных** (OptimisticConcurrencyException)

### Неконтролируемые (критические)
1. **Системные ошибки**:
   - OutOfMemoryException
   - StackOverflowException
   - AccessViolationException
2. **Инфраструктурные сбои**:
   - DatabaseConnectionException
   - ExternalServiceUnavailableException
3. **Runtime-краши**:
   - TypeInitializationException
   - JITCompilerException

> **Важно**: Неконтролируемые ошибки часто требуют перезапуска сервиса.

## Механизмы обработки в ASP.NET Core

### 1. Встроенные механизмы
```csharp
// Разные обработчики для разных окружений
if (env.IsDevelopment())
{
    app.UseDeveloperExceptionPage(); // Детальный stack trace
}
else
{
    app.UseExceptionHandler("/Error"); // User-friendly страница
}
```

### 2. Кастомный Middleware (рекомендуется для Web API)

```csharp

public class ErrorHandlingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ErrorHandlingMiddleware> _logger;

    public ErrorHandlingMiddleware(RequestDelegate next, ILogger<ErrorHandlingMiddleware> logger)
    {
        _next = next; // ссылка на след. делегат
        _logger = logger; // логирование никогда не бывает лишним, но не стоит логировать чувствительные данные (узнать у тех. лида по проекту, что можно логировать, а что нет?)
    }

    public async Task Invoke(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unhandled exception");
            context.Response.StatusCode = 500;
            context.Response.ContentType = "application/json";
            await context.Response.WriteAsync(JsonSerializer.Serialize(new
            {
                error = "Произошла внутренняя ошибка сервера"
            }));
        // В production не раскрываем ex.Message!
        }
    }
}
```

способ регистрации самописного middleware
```csharp
app.UseMiddleware<ErrorHandlingMiddleware>();
```


### 3. Exception Filters (точечная обработка)
например обработка только одной ошибки только в одном контроллере которого нигде нет больше
```csharp
public class GlobalExceptionFilter : IExceptionFilter
{
    private readonly ILogger<GlobalExceptionFilter> _logger;

    public GlobalExceptionFilter(ILogger<GlobalExceptionFilter> logger)
    {
        _logger = logger;
    }

    public void OnException(ExceptionContext context)
    {
        _logger.LogError(context.Exception, "Exception caught in filter");

        context.Result = new ObjectResult(new { error = "Что-то пошло не так" })
        {
            StatusCode = 500
        };
    }
}
```

способ регистрации самописного Filter
```csharp
services.AddControllers(options =>
{
    options.Filters.Add<GlobalExceptionFilter>();
});
```

## Best Practices

### 1. Problem Details (RFC 7807)

**Расширенная версия**:
```csharp
var problem = new ProblemDetails
{
    Status = 500,
    Title = "Ошибка сервера",
    Detail = ex.Message,
    Instance = context.Request.Path
};

context.Response.StatusCode = 500;
context.Response.ContentType = "application/problem+json";

var json = JsonSerializer.Serialize(problem);
await context.Response.WriteAsync(json);


можно расширять ProblemDetails за счет наследования

public class CustomProblemDetails : ProblemDetails
{
    public string TraceId { get; set; }
    public Dictionary<string, object> Metadata { get; set; }
}


public class ExtendedProblemDetails : ProblemDetails
{
    public string ErrorCode { get; set; }
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;
}
```

после исправления

```csharp
public class ErrorHandlingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ErrorHandlingMiddleware> _logger;

    public ErrorHandlingMiddleware(RequestDelegate next, ILogger<ErrorHandlingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task Invoke(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unhandled exception");
			var problem = new ProblemDetails
			{
			    Status = 500,
			    Title = "Ошибка сервера",
			    Detail = ex.Message,
			    Instance = context.Request.Path
			};
			
			context.Response.StatusCode = 500;
			context.Response.ContentType = "application/problem+json";
			
			var json = JsonSerializer.Serialize(problem);
			await context.Response.WriteAsync(json);
		}
	}
}
```

### 2. Обработка Validation Errors

```csharp
services.PostConfigure<ApiBehaviorOptions>(options =>
{
    options.InvalidModelStateResponseFactory = ctx => 
    {
        var problem = new ValidationProblemDetails(ctx.ModelState)
        {
            Type = "https://tools.ietf.org/html/rfc7231#section-6.5.1",
            Title = "One or more validation errors occurred"
        };
        return new BadRequestObjectResult(problem);
    };
});
```


### 3. Логирование

**Правила**:

- Всегда включать TraceId
    
- Не логировать PII-данные (пароли, токены)
    
- Использовать структурированное логгирование:

```csharp
_logger.LogError(
    "Ошибка при обработке запроса {RequestId}. Параметры: {Params}",
    traceId, 
    new { context.Request.Path, Query = context.Request.QueryString });
```

## Важные уточнения

1. **Middleware vs Filters**:
    
    - Middleware - для глобальных ошибок
        
    - Filters - для специфичных сценариев (например, валидация в контроллере)
        
2. **Безопасность**:
    
    - В production никогда не возвращайте stack trace
        
    - Используйте разные уровни детализации для разных окружений
        
3. **Производительность**:
    
    - Exception handling дорогой - для бизнес-ошибок лучше использовать Result-паттерн
        
    - Не используйте исключения для flow control



### **Подходы к валидации данных в ASP.NET Core**

---

## **1. DataAnnotations (Встроенная валидация)**

**Когда использовать**:

- Простые проверки (обязательные поля, длина строки, регулярные выражения).
    
- Быстрое прототипирование.
    

**Пример**:


```csharp
[ApiController] // Включает автоматическую валидацию
public class UserController : ControllerBase
{
    public class CreateUserRequest
    {
        [Required(ErrorMessage = "Имя обязательно")]
        [StringLength(50, MinimumLength = 2, ErrorMessage = "Длина имени от 2 до 50 символов")]
        public string Name { get; set; }

        [EmailAddress(ErrorMessage = "Некорректный email")]
        public string Email { get; set; }
    }

    [HttpPost("create")]
    public IActionResult Create([FromBody] CreateUserRequest request)
    {
        return Ok("OK");
    }
}
```
**Что возвращает при ошибке**:


```json

Copy

{
  "type": "https://tools.ietf.org/html/rfc7231#section-6.5.1",
  "title": "Validation Error",
  "status": 400,
  "errors": {
    "Name": ["Имя обязательно"],
    "Email": ["Некорректный email"]
  }
}
```

**Плюсы**:

- Встроено в ASP.NET Core.
    
- Минимальный boilerplate-код.
    

**Минусы**:

- Сложно расширять (например, проверка уникальности email в БД).
    
- Нет поддержки сложных условий (например, "если поле A равно X, то поле B обязательно").
    

---

## **2. FluentValidation (Кастомная валидация)**

**Когда использовать**:

- Сложные бизнес-правила.
    
- Переиспользуемые валидаторы.
    
- Валидация, требующая запросов к БД.
    

**Пример**:


```csharp

public class CreateUserRequestValidator : AbstractValidator<CreateUserRequest>
{
    public CreateUserRequestValidator(IUserRepository userRepo)
    {
        RuleFor(x => x.Name)
            .NotEmpty().WithMessage("Имя обязательно")
            .Length(2, 50).WithMessage("Длина имени от 2 до 50 символов");

        RuleFor(x => x.Email)
            .EmailAddress().WithMessage("Некорректный email")
            .MustAsync(async (email, _) => !await userRepo.ExistsAsync(email))
            .WithMessage("Email уже занят");
    }
}
```
**Регистрация**:


```csharp
services.AddScoped<IValidator<CreateUserRequest>, CreateUserRequestValidator>();
services.AddFluentValidationAutoValidation(); // Интеграция с ASP.NET Core
```
**Плюсы**:

- Гибкость (можно инжектить сервисы).
    
- Читаемый DSL-синтаксис.
    
- Поддержка асинхронных проверок.
    

**Минусы**:

- Требует подключения отдельной библиотеки (`FluentValidation`).
    

---

## **3. Аудит изменений (Audit Logging)**

**Зачем**:

- Отслеживание, кто и когда изменил данные.
    
- Восстановление предыдущих состояний.
    

### **Способы реализации**:

#### **1. Переопределение `SaveChanges` в EF Core**


```csharp

public override async Task<int> SaveChangesAsync(CancellationToken ct = default)
{
    var auditEntries = new List<AuditEntry>();

    foreach (var entry in ChangeTracker.Entries<IAuditable>())
    {
        if (entry.State == EntityState.Modified || entry.State == EntityState.Added)
        {
            auditEntries.Add(new AuditEntry
            {
                EntityId = entry.Entity.Id,
                OldValues = entry.State == EntityState.Modified 
                    ? JsonSerializer.Serialize(entry.OriginalValues.ToObject()) 
                    : null,
                NewValues = JsonSerializer.Serialize(entry.CurrentValues.ToObject()),
                ChangedBy = _currentUserService.GetUserId(),
                ChangedAt = DateTime.UtcNow
            });
        }
    }

    await _auditLogRepository.AddRangeAsync(auditEntries);
    return await base.SaveChangesAsync(ct);
}
```

```csharp
public class Dish : Entity
{
    public string Name { get; set; } = null!;
    public string Description { get; set; } = null!;
    public decimal Price { get; set; }
    public Guid CategoryId { get; set; }
    public Category Category { get; set; } = null!;
    public string? ImageUrl { get; set; } = string.Empty;
    public bool IsAvailable { get; set; }
    public IngredientList Ingredients { get; set; }
    public AllergenList Allergens { get; set; }
    public string PortionSize { get; set; }
	//для аудита
    public int RecordVersion { get;set; }
}
```


#### **2. Триггеры в БД (для high-load систем)**


```sql

CREATE TRIGGER trg_Dish_Audit
ON Dishes
AFTER INSERT, UPDATE, DELETE
AS
BEGIN
    INSERT INTO DishAuditLog (DishId, OldData, NewData, ChangedBy, ChangedAt)
    SELECT 
        ISNULL(i.Id, d.Id),
        (SELECT * FROM DELETED FOR JSON AUTO),
        (SELECT * FROM INSERTED FOR JSON AUTO),
        SYSTEM_USER,
        GETUTCDATE()
    FROM INSERTED i
    FULL JOIN DELETED d ON i.Id = d.Id;
END
```

**Плюсы триггеров**:

- Не влияет на производительность приложения.
    
- Работает даже при прямых SQL-запросах.
    

**Минусы**:

- Сложнее отлаживать.
    
- Привязка к конкретной СУБД.
    

---

## **Best Practices**

1. **Для валидации**:
    
    - `DataAnnotations` — для простых сценариев.
        
    - `FluentValidation` — для сложной логики.
        
2. **Для аудита**:
    
    - `SaveChanges` + `BackgroundService` — если нужно логировать в фоне.
        
    - Триггеры — если критична производительность.
        
3. **Возврат ошибок**:
    
    - Всегда используйте `ProblemDetails` для API.
        
    - В production скрывайте детали ошибок (`ex.Message` → "Произошла ошибка").
        
4. **Логирование**:
    
    - Структурированные логи (Serilog + Seq/Grafana).
        
    - Обязательно включать `TraceId` для отслеживания цепочек.
        

```csharp

// Пример логирования
_logger.LogError(
    "Ошибка при создании пользователя. RequestId: {TraceId}, Data: {@Request}",
    HttpContext.TraceIdentifier,
    request
);
```
**Итог**:

- Валидация должна быть явной и тестируемой.
    
- Аудит — обязателен для критичных данных.
    
- Ошибки — безопасны для пользователя и информативны для разработчика.


#задача поиграться с Program Details в отдельном проекте 
Program Details можно 
nuget: Microsoft.AspNetCore.Mvc.Core
Microsoft.AspNetCore.Mvc.Abstractions.dll

```csharp
[ApiController]
[Route("api/[controller]")]
public class TestController : ControllerBase
{
    [HttpGet("crash")]
    public IActionResult Crash()
    {
        throw new Exception("Что-то пошло не так"); //возвращает Program Details с 500 ошибкой
    }
}
```

Exception Filter vs Middleware
отлавливать только в контроллере Exception Filter
отлавливать все ошибки везде Middleware
управление pipeline Middleware
вернуть ошибку в виде IActionResult Exception Filter пример 302 код с редиректом на страницу ошибки (Razor Aplication)

#читать
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-9.0

#задача консольное приложение которое дергает API проекта
CancelationSource таймер на 300 мсек после которого идет обрыв соединения
т.е. моделирование CancelationToken внутри консольного приложения

многошаговые операции обрабатываются внутри API
но CancelationSource создается за пределами API в консольном приложении

План на новое занятие для ознакомления
Авторизация
Аутентификация

**Кэширование**
**Unit тесты** XUnit NSubstitute Moq

репозитории нет смысла тестировать
достаточно тестировать контроллеры, сервисы, валидаторы, handler CQRS
60% покрытие кода тестами необходимо и достаточно
тестировать при пограничных значениях
ветвление необходимо тоже тестировать
### основные правила тестирования
1. 1 тест 1 сценарий 
2. в самом тесте не должно быть сложной имплементации, может быть дублирования кода, чем проще тест чем лучше, рефлексию не использовать при тестировании или нужно четко понимать зачем это делается

#### Литература для изучения тестирования
- ART OF UNIT TESTING книга для unit тестирования для начала
- Хориков про тестирования для enterprice с принципами DDD для более продвинутого пользователя
- Паттерн XUnit


#задача для TenantViewModel и Создать сущность `Tenant` с полями сделать отдельный PR

остальную часть тикета сделать в другмо PR





















# Exception

Контролируемые 
1. Ошибка валидации
дополнить
и не контролируемые 
1. Падение системы OutOfMemoryException, системная ошибка сервера, crash runtime без возможности user frendly ответа все равно что отключить сервер
дополнить

Правильная обработка ошибок позволяет обезопасить приложения от взлома
ASP механизмы обработки ошибки
1. try catch

ASP Core из коробки IsDevelopment, Release
```csharp
//Страница ошибок
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
```
для прода это не используется

UseExceptionHandler позволяет сделать redirect на указанный route характерно для Razor приложения

2. Самописный обработчик Middleware

```csharp
public class ErrorHandlingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ErrorHandlingMiddleware> _logger;

    public ErrorHandlingMiddleware(RequestDelegate next, ILogger<ErrorHandlingMiddleware> logger)
    {
        _next = next; // ссылка на след. делегат
        _logger = logger; // логирование никогда не бывает лишним, но не стоит логировать чувствительные данные (узнать у тех. лида по проекту, что можно логировать, а что нет?)
    }

    public async Task Invoke(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unhandled exception");
            context.Response.StatusCode = 500;
            context.Response.ContentType = "application/json";
            await context.Response.WriteAsync(JsonSerializer.Serialize(new
            {
                error = "Произошла внутренняя ошибка сервера"
            }));
        }
    }
}
```

способ регистрации самописного middleware
```csharp
app.UseMiddleware<ErrorHandlingMiddleware>();
```

3. Фильтры исключений Exception Filters (точечная обработка например обработка только одной ошибки только в одном контроллере которого нигде нет больше)

Exception Filters рекомендуется использовать до того как уйдет ошибка в Middleware

Exception Filters унаследована от ASP MVC

```csharp
public class GlobalExceptionFilter : IExceptionFilter
{
    private readonly ILogger<GlobalExceptionFilter> _logger;

    public GlobalExceptionFilter(ILogger<GlobalExceptionFilter> logger)
    {
        _logger = logger;
    }

    public void OnException(ExceptionContext context)
    {
        _logger.LogError(context.Exception, "Exception caught in filter");

        context.Result = new ObjectResult(new { error = "Что-то пошло не так" })
        {
            StatusCode = 500
        };
    }
}
```


```csharp
services.AddControllers(options =>
{
    options.Filters.Add<GlobalExceptionFilter>();
});
```

Middleware > Exception Filters для глобальных Exception

### способы показывания информация об ошибке

1. UseStatusCodePages (используется для временных стабов, сложно сделать что то user frendly, актуально для создания "заглушок")

```csharp
app.UseStatusCodePages(async statusCodeContext =>
{
    var response = statusCodeContext.HttpContext.Response;
    response.ContentType = "text/plain";
    
    await response.WriteAsync(
        $"Статусный код ошибки: {response.StatusCode}");
});
```

2.  app.UseStatusCodePagesWithRedirects("/Error/{0}"); redirect на специфичную страницу Error Page, актуально для Razor, в web api не используют

Problem Deatails способ предоставления информации об ошибке в формате JSON характерно для WEB API

TraceID агрегировать данные и построить цепочку выполнения


```csharp
var problem = new ProblemDetails
{
    Status = 500,
    Title = "Ошибка сервера",
    Detail = ex.Message,
    Instance = context.Request.Path
};

context.Response.StatusCode = 500;
context.Response.ContentType = "application/problem+json";

var json = JsonSerializer.Serialize(problem);
await context.Response.WriteAsync(json);
```

после исправления

```csharp
public class ErrorHandlingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ErrorHandlingMiddleware> _logger;

    public ErrorHandlingMiddleware(RequestDelegate next, ILogger<ErrorHandlingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task Invoke(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unhandled exception");
			var problem = new ProblemDetails
			{
			    Status = 500,
			    Title = "Ошибка сервера",
			    Detail = ex.Message,
			    Instance = context.Request.Path
			};
			
			context.Response.StatusCode = 500;
			context.Response.ContentType = "application/problem+json";
			
			var json = JsonSerializer.Serialize(problem);
			await context.Response.WriteAsync(json);
		}
	}
}
```

можно расширять ProblemDetails за счет наследования

```csharp
public class ExtendedProblemDetails : ProblemDetails
{
    public string ErrorCode { get; set; }
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;
}
```

status из ProblemDetails это http code серверная ошибка 
ErrorCode это коды принятые внутри приложения, не всегда можно отловить все типы ошибок и указать соответствующий ErrorCode,
ErrorCode заменяются структурированным логгированием с использованием placeholder
(grafana seq)

Validation Problem Details дополнить?


2 подхода при разработка

1. DataAnnotations атрибуты которые позволяет разметить поля моделей
сложно расширяемый
следует использовать для простых валидаций

```csharp
[ApiController] // обязательный атрибут для DataAnnotations, без этого не включится валидация Name
public class TestController : ControllerBase
	{
	public class CreateUserRequest
	{
	    [Required]
	    public string Name { get; set; }
	}
	
	[HttpPost("create")]
	public IActionResult Create([FromBody] CreateUserRequest request)
	{
	    return Ok("OK");
	}
}
```

ошибка которую вернет данный пример

```csharp
{
  "type": "https://tools.ietf.org/html/rfc7231#section-6.5.1",
  "title": "One or more validation errors occurred.",
  "status": 400,
  "errors": {
    "Name": ["The Name field is required."]
  }
}
```

2. CustomValidation например FluentValidation

как только приложение ушло в прод
ProblemDetails для отправки клиенту user frendly сообщения
для backend основной инструмент диагностики логи 

аудит изменения сущностей за счет создания дополнительных сущностей
и формирования слепков изменений

```csharp
public class Dish : Entity
{
    public string Name { get; set; } = null!;
    public string Description { get; set; } = null!;
    public decimal Price { get; set; }
    public Guid CategoryId { get; set; }
    public Category Category { get; set; } = null!;
    public string? ImageUrl { get; set; } = string.Empty;
    public bool IsAvailable { get; set; }
    public IngredientList Ingredients { get; set; }
    public AllergenList Allergens { get; set; }
    public string PortionSize { get; set; }
	//для аудита
    public int RecordVersion { get;set; }
}
```

1. В EF Core SaveChanges можно переопределить и брать слепки для сохранения например через BackgroundService (BackgroundService для быстродействия)
2. На уровне базы данных за триггеров, для случаев ОЧЕНЬ интенсивной работы с данными единственный случай простого решения без деградации быстродействия


#задача поиграться с Program Details в отдельном проекте 
Program Details можно 
nuget: Microsoft.AspNetCore.Mvc.Core
Microsoft.AspNetCore.Mvc.Abstractions.dll

```csharp
[ApiController]
[Route("api/[controller]")]
public class TestController : ControllerBase
{
    [HttpGet("crash")]
    public IActionResult Crash()
    {
        throw new Exception("Что-то пошло не так"); //возвращает Program Details с 500 ошибкой
    }
}
```

Exception Filter vs Middleware
отлавливать только в контроллере Exception Filter
отлавливать все ошибки везде Middleware
управление pipeline Middleware
вернуть ошибку в виде IActionResult Exception Filter пример 302 код с редиректом на страницу ошибки (Razor Aplication)

#читать
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-9.0

#задача консольное приложение которое дергает API проекта
CancelationSource таймер на 300 мсек после которого идет обрыв соединения
т.е. моделирование CancelationToken внутри консольного приложения

многошаговые операции обрабатываются внутри API
но CancelationSource создается за пределами API в консольном приложении

План на новое занятие для ознакомления
Авторизация
Аутентификация

**Кэширование**
**Unit тесты** XUnit NSubstitute Moq

репозитории нет смысла тестировать
достаточно тестировать контроллеры, сервисы, валидаторы, handler CQRS
60% покрытие кода тестами необходимо и достаточно
тестировать при пограничных значениях
ветвление необходимо тоже тестировать
### основные правила тестирования
1. 1 тест 1 сценарий 
2. в самом тесте не должно быть сложной имплементации, может быть дублирования кода, чем проще тест чем лучше, рефлексию не использовать при тестировании или нужно четко понимать зачем это делается

#### Литература для изучения тестирования
- ART OF UNIT TESTING книга для unit тестирования для начала
- Хориков про тестирования для enterprice с принципами DDD для более продвинутого пользователя
- Паттерн XUnit


#задача для TenantViewModel и Создать сущность `Tenant` с полями сделать отдельный PR

остальную часть тикета сделать в другмо PR